正则表达式中/i,/g,/ig,/m的区别和含义：

/i(忽略大小写)

/g(全文查找出现的所有匹配字符，执行全局匹配，查找所有匹配而非找到第一个匹配后停止)

/m(多行查找)

/gi(全文查找，忽略大小写)

/ig(全文查找、忽略大小写)

[abc]	查找方括号之间的任何自负

[^abc]	查找任何不在方括号之间的字符

.	查找单个字符，除了换行和行结束字符。

\w	查找单词字符
​	
\W	查找非单词字符

\d	查找数字

\D	查找非数字字符

\s	查找空白字符

\S	查找非空白字符

\b	匹配单词边界

\B	匹配非单词边界

\0	查找NUL字符

\n	查找换行符

\f	查找换页符

\r	查找回车符

\t	查找制表符



n+	匹配任何包含至少一个n的字符串。

n*	匹配任何包含零个或多个n的字符串

n?	匹配任何包含零个或1个n的字符串

n{X}	匹配包含X个n的序列的字符串

n{X, Y}	匹配包含X到Y个n的序列字符串

n{X,}	匹配包含至少X个n的序列的字符串

n$	匹配任何结尾为n的字符串

^n	匹配任何开头为n的字符串

?=n	匹配任何其后紧随制定字符串n的字符串

?!=n	匹配任何其后没有紧接指定字符串n的字符串



str.match(/regexp/g) —> 其中regexp中存在()则算一个匹配，有多少个()，全局匹配就会有多少个结果。比如：



```javascript
var str = "For more information, see Chapter 3.4.5.1";
var re = /(chapter \d+(\.\d)*)/i;
var found = str.match(re);

console.log(found); //["see Chapter 3.4.5.1", "Chapter 3.4.5.1", ".1", index: 22, input: "For more information, see Chapter 3.4.5.1"]
```

**index** 这里指的是第一个匹配的索引，**input** 则是匹配的字符串。

match的返回值是一个数组



同上

```javascript
regexp.exec(obj);
```



### 贪婪模式与非贪婪模式

默认情况下，所有的限定词都是贪婪模式，表示尽可能多的去捕获字符，而在限定词后增加`?`，则是非贪婪模式，表示尽可能少的去捕获字符，如下：

```Javascript
var str = "aaab",
    reg1 = /a+/, //贪婪模式
    reg2 = /a+?/;//非贪婪模式
console.log(str.match(reg1)); //["aaa"], 由于是贪婪模式, 捕获了所有的a
console.log(str.match(reg2)); //["a"], 由于是非贪婪模式, 只捕获到第一个a

```

实际上, 非贪婪模式非常有效, 特别是当匹配html标签时. 比如匹配一个配对出现的div, 方案一可能会匹配到很多的div标签对, 而方案二则只会匹配一个div标签对.

```Javascript
var str = "<div class='v1'><div class='v2'>test</div><input type='text'/></div>";
var reg1 = /<div.*<\/div>/; //方案一,贪婪匹配
var reg2 = /<div.*?<\/div>/;//方案二,非贪婪匹配
console.log(str.match(reg1));//"<div class='v1'><div class='v2'>test</div><input type='text'/></div>"
console.log(str.match(reg2));//"<div class='v1'><div class='v2'>test</div>"

```



### 区间量词的非贪婪模式

一般情况下，非贪婪模式，我们使用的是`"?"`或`"+?"`这种形式，还有一种`"{n, m}"`。

区间量词`"{n, m}"`也是匹配优先，虽有匹配次数上限，但是到达上线之前，它依然是尽可能多的匹配，而`"{n, m}?"`则表示在区间范围内，尽可能少的匹配。

**注意**：

- 能达到同样匹配效果的贪婪和非贪婪模式，通常是贪婪模式的匹配效率较高。
- 所有的非贪婪模式，都可以通过修改量词修饰的子表达式，转换为贪婪模式。
- 贪婪模式可以与`固化分组`（后面会讲到）结合，提升匹配效率，而非贪婪模式却不可以。

### 分组

正则的分组做药通过`小括号`来实现，括号包裹的子表达式作为一个分组，括号后可以紧跟限定词表示重复次数，如下，小括号内包裹的abc便是一个分组：

```javascript
/(abc)+/.test('abc123') === true
```

那分组有什么用呢？一般来说，分组为了方便的表示重复次数，除此之外，还有一个作用就是用于捕获，请往下看。

#### 捕获型性分组

捕获性分组，通常由一对小括号加上子表达式组成。捕获性分组会创建`反向引用`，每个反向引用都由一个编号或名称来标识，js中主要是通过`$[编号]`或者`\[编号]`表示法进行引用。

```Javascript
var color = '#808080';
var output = color.replace(/#(\d+)/, "$1"+"~~");//自然也可以写成"$1~~"

console.log(RegExp.$1); //808080
console.log(output); //808080~~
```

以上，(\d+)表示一个捕获性分组，`RegExp.$1`指向该分组捕获的内容，`$[编号]`这种引用通常在**正则表达式之外**使用。`\[编号]`这种引用却可以在**正则表达式中**使用，可用于匹配不同位置相同部分的子串。

#### 非捕获性分组

非捕获性分组, 通常由一对括号加上”?:”加上子表达式组成, 非捕获性分组不会创建反向引用, 就好像没有括号一样. 如下:

```Javascript
var color = "#808080";
var output = color.replace(/#(?:\d+)/,"$1"+"~~");
console.log(RegExp.$1);//""
console.log(output);//$1~~

```

以上, (?:\d+) 表示一个非捕获性分组, 由于分组不捕获任何内容, 所以, `RegExp.$1` 就指向了空字符串.

同时, 由于`$1` 的反向引用不存在, 因此最终它被当成了普通字符串进行替换.

实际上, 捕获性分组和无捕获性分组在搜索效率方面也没什么不同, 没有哪一个比另一个更快.



#### 正则表达式高阶技能-零宽断言

> 零宽断言，又叫环视。环视只进行子表达式的匹配，匹配到的内容不保存到最终的匹配结果，由于匹配是零宽度的，故最终匹配到的只是一个位置

环视按照方向划分，有顺序和逆序两种（也叫前瞻和后瞻），按照是否匹配有肯定和否定两种，组合之，便有4种环视，4种环视并不复杂，如下便是它们的描述。

| 字符             | 描述                                       | 示例                                       |
| :------------- | :--------------------------------------- | ---------------------------------------- |
| (?:*pattern*)  | 非捕获性分组, 匹配pattern的位置, 但不捕获匹配结果.也就是说不创建反向引用, 就好像没有括号一样. | ‘abcd(?:e)匹配’abcde                       |
| (?=*pattern*)  | **顺序肯定环视**, 匹配后面是pattern 的位置, 不捕获匹配结果.   | ‘Windows (?=2000)’匹配 “Windows2000” 中的 “Windows”; 不匹配 “Windows3.1” 中的 “Windows” |
| (?!*pattern*)  | **顺序否定环视**, 匹配后面不是 pattern 的位置, 不捕获匹配结果. | ‘Windows (?!2000)’匹配 “Windows3.1” 中的 “Windows”; 不匹配 “Windows2000” 中的 “Windows” |
| (?<=*pattern*) | **逆序肯定环视**, 匹配前面是 pattern 的位置, 不捕获匹配结果.  | ‘(?<=Office)2000’匹配 “ Office2000” 中的 “2000”; 不匹配 “Windows2000” 中的 “2000” |
| (?<!*pattern*) | **逆序否定环视**, 匹配前面不是 pattern 的位置, 不捕获匹配结果. | ‘(?<!Office)2000’匹配 “ Windows2000” 中的 “2000”; 不匹配 “ Office2000” 中的 “2000” |

非捕获性分组由于结构与环视相似，故在表中，以做对比，以上4种环视，目前javascript只支持前两种，就是只支持 **顺序肯定环视** 和 **顺序否定环视**. 下面我们通过实例来帮助理解下:

```javascript
var str = "123abc789",s;
//没有使用环视,abc直接被替换
s = str.replace(/abc/,456);
console.log(s); //123456789
//使用了顺序肯定环视,捕获到了a前面的位置,所以abc没有被替换,只是将3替换成了3456
s = str.replace(/3(?=abc)/,3456);
console.log(s); //123456abc789
//使用了顺序否定环视,由于3后面跟着abc,不满意条件,故捕获失败,所以原字符串没有被替换
s = str.replace(/3(?!abc)/,3456);
console.log(s); //123abc789
```



#### 场景回顾

假如现在js通过ajax获取到一段html代码如下：

```Javascript
	
var responseText = "<div data='dev.xxx.txt'></div><img src='dev.xxx.png' />";

```

现我们需要替换img标签的src 属性中的 “dev”字符串 为 “test” 字符串.

① 由于上述 responseText 字符串中包含至少两个子字符串 “dev”, 显然不能直接 replace 字符串 “dev”为 “test”.

② 同时由于 js 中不支持逆序环视, 我们也不能在正则中判断前缀为 “src=’”, 然后再替换”dev”.

③ 我们注意到 img 标签的 src 属性以 “.png” 结尾, 基于此, 就可以使用顺序肯定环视. 如下:

```Javascript
var reg = /dev(?=[^']*png)/; //为了防止匹配到第一个dev, 通配符前面需要排除单引号或者是尖括号
var str = responseText.replace(reg,"test");
console.log(str);//<div data='dev.xxx'></div><img src='test.xxx.png' />
```

当然, 以上不止顺序肯定环视一种解法, 捕获性分组同样可以做到. 那么环视高级在哪里呢? 环视高级的地方就在于它通过一次捕获就可以定位到一个位置, 对于复杂的文本替换场景, 常有奇效, 而分组则需要更多的操作. 请往下看.



#### 千位分隔符

> 千位分隔符, 顾名思义, 就是数字中的逗号. 参考西方的习惯, 数字之中加入一个符号, 避免因数字太长难以直观的看出它的值. 故而数字之中, 每隔三位添加一个逗号, 即千位分隔符.

那么怎么将一串数字转化为千位分隔符形式呢?

```Javascript
 var str = "1234567890";
(+str).toLocaleString();//"1,234,567,890"

```

如上, `toLocaleString()` 返回当前对象的”本地化”字符串形式.

- 如果该对象是Number类型, 那么将返回该数值的按照特定符号分割的字符串形式.
- 如果该对象是Array类型, 那么先将数组中的每项转化为字符串, 然后将这些字符串以指定分隔符连接起来并返回.

`toLocaleString` 方法特殊, 有本地化特性, 对于天朝, 默认的分隔符是英文逗号. 因此使用它恰好可以将数值转化为千位分隔符形式的字符串. 如果考虑到国际化, 以上方法就有可能会失效了.

我们尝试使用环视来处理下.



```Javascript
function thousand(str){
  return str.replace(/(?!^)(?=([0-9]{3})+$)/g,',');
}
console.log(thousand(str));//"1,234,567,890"
console.log(thousand("123456"));//"123,456"
console.log(thousand("1234567879876543210"));//"1,234,567,879,876,543,210"

```

上述使用到的正则分为两块. `(?!^)` 和 `(?=([0-9]{3})+$)`. 我们先来看后面的部分, 然后逐步分析之.

1. “[0-9]{3}” 表示连续3位数字.
2. “([0-9]{3})+” 表示连续3位数字至少出现一次或更多次.
3. “([0-9]{3})+$” 表示连续3的正整数倍的数字, 直到字符串末尾.
4. 那么 `(?=([0-9]{3})+$)` 就表示匹配一个零宽度的位置, 并且从这个位置到字符串末尾, 中间拥有3的正整数倍的数字.
5. 正则表达式使用全局匹配g, 表示匹配到一个位置后, 它会继续匹配, 直至匹配不到.
6. 将这个位置替换为逗号, 实际上就是每3位数字添加一个逗号.
7. 当然对于字符串”123456”这种刚好拥有3的正整数倍的数字的, 当然不能在1前面添加逗号. 那么使用 `(?!^)` 就指定了这个替换的位置不能为起始位置.

千位分隔符实例, 展示了环视的强大, 一步到位.



[正则表达式前端使用手册](http://louiszhai.github.io/2016/06/13/regexp/#导读)